mod flags {
    // Rust analyzer can't resolve this macro
    // so just ignore the error :(
    // https://github.com/matklad/xflags/issues/14
    xflags::xflags! {
        src "./src/bin/main.rs"
        cmd polar-analyzer {
            default cmd lsp-server {
                optional --tcp port: u32
            }
        }
    }
    // generated start
    // The following code is generated by `xflags` macro.
    // Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
    #[derive(Debug)]
    pub struct PolarAnalyzer {
        pub subcommand: PolarAnalyzerCmd,
    }

    #[derive(Debug)]
    pub enum PolarAnalyzerCmd {
        LspServer(LspServer),
    }

    #[derive(Debug)]
    pub struct LspServer {
        pub tcp: Option<u32>,
    }

    impl PolarAnalyzer {
        pub const HELP: &'static str = Self::HELP_;

        #[allow(dead_code)]
        pub fn from_env() -> xflags::Result<Self> {
            Self::from_env_()
        }

        #[allow(dead_code)]
        pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
            Self::from_vec_(args)
        }
    }
    // generated end
}

fn main() {
    match try_main() {
        Ok(_) => {
            // do nothing
        }
        Err(e) => {
            println!("{}", e);
            println!("{}", flags::PolarAnalyzer::HELP);
            std::process::exit(101);
        }
    }
}

fn try_main() -> xflags::Result<()> {
    let flags = flags::PolarAnalyzer::from_env()?;
    match flags.subcommand {
        flags::PolarAnalyzerCmd::LspServer(flags::LspServer { tcp }) => {
            let rt = tokio::runtime::Builder::new_current_thread()
                .enable_all()
                .build()
                .unwrap();
            match tcp {
                Some(port) => rt
                    .block_on(polar_analyzer::server::run_tcp_server(None, port))
                    .unwrap(),
                None => rt.block_on(polar_analyzer::server::run_stdio_server(None)),
            };
        }
    }
    Ok(())
}
